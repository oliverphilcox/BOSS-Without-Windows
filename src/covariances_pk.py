# covariances_pk.py (Oliver Philcox, 2021)
### Covariance definitions for optimal estimator P_ell(k) and bispectrum estimation

import sys, os, copy, time
import numpy as np
# custom definitions
sys.path.append('../src')
from opt_utilities import ft, ift

def applyC(input_map,nbar,MAS_mat,pk_map,Y_lms,k_grids,r_grids,v_cell,shot_fac,include_pix=True):
    """Apply the fiducial covariance to a pixel map x, i.e. C[x] = S[x]+N[x].

    We decompose P(k;x) = \sum_l P_l(k) L_l(k.x) where x is the position of the second galaxy and use spherical harmonic decompositions.
    P_l(k) are the even fiducial power spectrum multipoles, taken as an input (including the MAS window if relevant).

    Parameters
    ----------
    input_map : ndarray
        The input map to apply the covariance to.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    pk_map : ndarray
        The fiducial power spectrum multipoles (only used with ML weights).
    Y_lms : list
        List of spherical harmonic functions, generated by the compute_spherical_harmonic_functions() function.
    k_grids : ndarray
        3D grids containing the (k_x,k_y,k_z) values.
    r_grids : ndarray
        3D grids containing the (r_x,r_y,r_z) values.
    v_cell : float
        Cell volume.
    shot_fac : float
        Shot noise factor.
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).

    Returns
    -------
    ndarray
        Covariance matrix applied to the input map.
    """
    return applyS(input_map,nbar,MAS_mat,pk_map,Y_lms,k_grids,r_grids,v_cell,include_pix=include_pix)+applyN(input_map,nbar,MAS_mat,v_cell,shot_fac,include_pix=include_pix)

def applyS(input_map,nbar,MAS_mat,pk_map,Y_lms,k_grids,r_grids,v_cell,include_pix=True):
    """Apply S optionally including MAS effects. This includes all even multipoles up to len(pk_map).
    We assume that the nbar map is unpixellized.
    
        Parameters
    ----------
    input_map : ndarray
        The input map to apply the signal covariance matrix to.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    pk_map : ndarray
        The fiducial power spectrum multipoles (only used with ML weights).
    Y_lms : list
        List of spherical harmonic functions, generated by the compute_spherical_harmonic_functions() function.
    k_grids : ndarray
        3D grids containing the (k_x,k_y,k_z) values.
    r_grids : ndarray
        3D grids containing the (r_x,r_y,r_z) values.
    v_cell : float
        Cell volume.
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).

    Returns
    -------
    ndarray
        Signal covariance matrix applied to the input map.
    """
    if include_pix:
        tmp_map = ift(ft(input_map)/MAS_mat)*nbar
    else:
        tmp_map = input_map*nbar
    f_nxP = 0.
    n_l = len(pk_map)
    for i in range(n_l):
        # Compute Sum_m Y_lm(k)FT[Y_lm(r)n(r)x(r)]
        f_nx_l = 0.
        for m_i in range(len(Y_lms[i])):
            f_nx_l += ft(tmp_map*Y_lms[i][m_i](*r_grids))*Y_lms[i][m_i](*k_grids)

        # Add contribution to # Sum_L P_L(k) (4pi)/(2L+1) SUM_M Y_LM*(k) F[n x Y_LM](k)
        f_nxP += 4.*np.pi/(4.*i+1.)*f_nx_l*pk_map[i]

    # Compute Sum_L IFT[P_ell(k) (4pi)/(2L+1) Sum_M Y_LM*(k) F[n x Y_LM](k)](r)
    if include_pix:
        return ift(ft(nbar*ift(f_nxP))/MAS_mat)/v_cell
    else:
        return nbar*ift(f_nxP)/v_cell

def applyN(input_map,nbar,MAS_mat,v_cell,shot_fac,include_pix=True):
    """Apply N, optionally including MAS effects. We assume the nbar map does not contain MAS effects.
    shot_fac is equal to [<w_data^2> + alpha^2 < w_randoms^2>]/<w_data>.
    
    Parameters
    ----------
    input_map : ndarray
        The input map to apply the N matrix to.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    v_cell : float
        Cell volume.
    shot_fac : float
        Shot noise factor.
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).

    Returns
    -------
    ndarray
        Noise covariance matrix applied to the input map.
    """
    if include_pix:
        return shot_fac*ift(1./MAS_mat*ft(nbar*ift(ft(input_map)/MAS_mat)))/v_cell
    else:
        return shot_fac*nbar*input_map/v_cell

def applyCinv_fkp(input_map,nbar,MAS_mat,v_cell,shot_fac,P_fkp=1e4,include_pix=True):
    """Apply C^-1 in the approximate FKP prescription. This assumes C(r,r') = delta_D(r-r')n(r)[a_shot+n(r)P_fkp].

    We optionally include the full MAS effects also, and use only pixels with (unwindowed) nbar>0.
    
        Parameters
    ----------
    input_map : ndarray
        The input map to apply the inverse covariance to.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    v_cell : float
        Cell volume.
    shot_fac : float
        Shot noise factor.
    P_fkp : float, optional
        FKP power spectrum weight (default: 1e4).
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).

    Returns
    -------
    ndarray
        FKP covariance matrix applied to the input map.
    """
    fkp_weight = nbar*(nbar*P_fkp+shot_fac)
    ratio_map = np.zeros(input_map.shape,dtype=np.complex64)
    if include_pix:
        tmp_map = ift(ft(input_map)*MAS_mat)
    else:
        tmp_map = input_map
    f = nbar>0 # don't include any empty cells!
    ratio_map[f] = tmp_map[f]/fkp_weight[f]
    if include_pix:
        return ift(MAS_mat*ft(ratio_map))*v_cell
    else:
        return ratio_map*v_cell

def applyCinv_approx(input_map,nbar,MAS_mat,v_cell,shot_fac,P_fkp=1e4,include_pix=True):
    """Apply an approximate C^-1 based on N^-1, including an FKP rescaling. This is independent of the input cosmology.

     Note we filter out any cells with n_bar = 0

    Parameters
    ----------
    input_map : ndarray
        The input map to apply the inverse covariance to.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    v_cell : float
        Cell volume.
    shot_fac : float
        Shot noise factor.
    P_fkp : float, optional
        FKP power spectrum weight (default: 1e4).
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).

    Returns
    -------
    ndarray
        Approximate covariance matrix applied to the input map.
    """
    return applyCinv_fkp(input_map,nbar,MAS_mat,v_cell,shot_fac,P_fkp=P_fkp,include_pix=include_pix)

def apply_inv_preconditoner(pix,nbar,MAS_mat,v_cell,shot_fac,P_fkp=1e4,include_pix=True):
    """Apply the inverse preconditioner matrix, here using the small-scale FKP form.
    
    Parameters
    ----------
    pix : ndarray
        The input map to apply the preconditioner to.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    v_cell : float
        Cell volume.
    shot_fac : float
        Shot noise factor.
    P_fkp : float, optional
        FKP power spectrum weight (default: 1e4).
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).

    Returns
    -------
    ndarray
        The preconditioner matrix applied to the input map.
    """
    return applyCinv_approx(pix,nbar,MAS_mat,v_cell,shot_fac,P_fkp=P_fkp,include_pix=include_pix)

def applyCinv(pix,nbar,MAS_mat,P3D,Y_lms,k_grids,r_grids,v_cell,shot_fac,applyC=applyC,applyCinv_approx=applyCinv_approx,
              max_it = 100, abs_tol = 1e-8, rel_tol = None, verb=1,
             apply_inv_preconditoner=apply_inv_preconditoner,P_fkp=1e4,include_pix=True):
    """Solve the system C.x = pix, i.e. x = C^-1 . pix via preconditioned conjugate-gradient descent.
    This uses an input set of P_L(k) multipoles and spherical harmonics to construct the covariance.
    
    Parameters
    ----------
    pix : ndarray
        The input map to apply the inverse covariance to.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    P3D : ndarray
        The 3D power spectrum multipoles.
    Y_lms : list
        List of spherical harmonic functions, generated by Ylm.
    k_grids : ndarray
        The k-grids used to construct the covariance.
    r_grids : ndarray
        The r-grids used to construct the covariance.
    v_cell : float
        Cell volume.
    shot_fac : float
        Shot noise factor.
    applyC : function, optional
        Function to apply the covariance matrix to the input map.
    applyCinv_approx : function, optional
        Function to apply the approximate covariance matrix to the input map.
    max_it : int, optional
        Maximum number of iterations (default: 100).
    abs_tol : float, optional
        Absolute tolerance (default: 1e-8).
    rel_tol : float, optional
        Relative tolerance (default: None).
    verb : int, optional
        Verbosity level (default: 1).
    apply_inv_preconditoner : function, optional
        The function to apply the inverse preconditioner to the input pixels.
    P_fkp : float, optional
        FKP power spectrum weight (default: 1e4).
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).

    Returns
    -------
    ndarray
        The inverse covariance matrix applied (approximately) to the input map.
    """
    start = time.time()

    # define initial guess for inverse and first term in sequence
    x = applyCinv_approx(pix,nbar,MAS_mat,v_cell,shot_fac,P_fkp=P_fkp,include_pix=include_pix)
    r = pix - applyC(x,nbar,MAS_mat,P3D,Y_lms,k_grids,r_grids,v_cell,shot_fac,include_pix=include_pix)
    p = apply_inv_preconditoner(r,nbar,MAS_mat,v_cell,shot_fac,P_fkp=P_fkp,include_pix=include_pix)
    C_p = applyC(p,nbar,MAS_mat,P3D,Y_lms,k_grids,r_grids,v_cell,shot_fac,include_pix=include_pix)

    pre_r = apply_inv_preconditoner(r,nbar,MAS_mat,v_cell,shot_fac,P_fkp=P_fkp,include_pix=include_pix)
    old_sum = np.sum(r*pre_r)
    init_sum = old_sum.copy()
    alpha = old_sum/np.sum(p*C_p)
    save_sum = old_sum.copy()

    assert max_it < len(pix.ravel())

    for i in range(max_it):
        if i%10==0 and i>0:
            # Check for stalling and stop if stalled
            if np.abs((save_sum-old_sum)/old_sum)<0.05:
                if verb: print("Inversion stalled after step %d; exiting (ratio %.2e/%.2e)"%(i+1,new_sum,init_sum))
                break
            save_sum = old_sum

        # update x
        x = x+alpha*p
        # update r
        r = r-alpha*C_p
        # update tilde-C^-1.r
        pre_r = apply_inv_preconditoner(r,nbar,MAS_mat,v_cell,shot_fac,P_fkp=P_fkp,include_pix=include_pix)
        # update sum(r * tilde-C^-1.r)
        new_sum = np.sum(r*pre_r)
        # update p
        p = pre_r + (new_sum/old_sum)*p
        # Check for convergence
        if new_sum/init_sum<0:
            print("Bad sum: %.2e, %.2e"%(new_sum,init_sum))
        if rel_tol!=None:
            if np.sqrt(new_sum/init_sum)<rel_tol:
                if verb: print("Inversion stopped early after %d iterations (ratio %.2e/%.2e)"%(i+1,new_sum,init_sum))
                break
        else:
            if np.sqrt(new_sum)<abs_tol:
                if verb: print("Inversion stopped early after %d iterations (ratio %.2e/%.2e)"%(i+1,new_sum,init_sum))
                break
        # update sum
        old_sum = new_sum
        # update C.p
        C_p = applyC(p,nbar,MAS_mat,P3D,Y_lms,k_grids,r_grids,v_cell,shot_fac,include_pix=include_pix)
        # compute alpha
        alpha = old_sum/np.sum(p*C_p)
    if i==max_it-1:
        print("CGD did not stop early: is this converged? (ratio %.2e/%.2e)"%(new_sum,init_sum))
    if verb:
        print("\nInversion took %d seconds"%(time.time()-start))
    return x

def applyC_alpha(input_map,nbar,MAS_mat,Y_lms,k_grids,r_grids,v_cell,k_filters,k_norm,n_k,lmax,include_pix=True,data=False):
    """Compute derivatives C_{,alpha}(r,r') for the data covariance C. We assume C_D = Sum_alpha C_{,alpha} p_alpha.
    We compute the derivatives with respect to all power spectrum bins and even multipoles, up to ell=lmax.

    This includes pixellation in full if include_pix=True, else it just multiplies by the MAS window if data=True.

    Parameters
    ----------
    input_map : ndarray
        The input map.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    Y_lms : list
        List of spherical harmonic functions, generated by Ylm.
    k_grids : ndarray
        3D grids containing the (k_x,k_y,k_z) values.
    r_grids : ndarray
        3D grids containing the (r_x,r_y,r_z) values.
    v_cell : float
        Cell volume.
    k_filters : ndarray
        3D boolean maps describing the k bins.
    k_norm : float
        3D map of |k|.
    n_k : int
        Total number of k bins.
    lmax : int
        Maximum multipole (should be even).
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).
    data : bool, optional
        Whether to include the pixelation in data covariance (default: False).

    Returns
    -------
    ndarray
        The derivatives C_{,alpha}(r,r') applied to the input map x(r').
    """
    out_derivs = []

    if include_pix:
        tmp_map = ift(ft(input_map)/MAS_mat)*nbar
    else:
        tmp_map = input_map*nbar

    n_l = lmax//2+1

    for i in range(n_l):

        # Compute Sum_m Y_lm(k)FT[Y_lm(r)n(r)x(r)]
        f_nx_l = 0.

        for m_i in range(len(Y_lms[i])):
            f_nx_l += ft(tmp_map*Y_lms[i][m_i](*r_grids))*Y_lms[i][m_i](*k_grids)

        if not include_pix:
            if data:
                # add in factor of M^2 to remove pixellation effects (for data only)
                f_nx_l *= MAS_mat**2.

        for a in range(n_k):
            # Compute Theta^a(k) (4pi)/(2L+1) SUM_M Y_LM*(k) F[n x Y_LM](k)
            tmp2 = 4.*np.pi/(4.*i+1.)*k_filters(a,k_norm)*f_nx_l

            # Add to output array
            if include_pix:
                out_derivs.append(ift(ft(nbar*ift(tmp2))/MAS_mat)/v_cell)
            else:
                out_derivs.append(nbar*ift(tmp2)/v_cell)

    return out_derivs


def applyC_alpha_single(input_map,nbar,MAS_mat,Y_lms,k_grids,r_grids,v_cell,k_filters,k_norm,i,a,include_pix=True,data=False):
    """Compute derivatives C_{,alpha}(r,r') for the data covariance C. We assume C_D = Sum_alpha C_{,alpha} p_alpha.
    We compute the derivatives with respect to a single power spectrum bins and a single even multipole.

    This includes pixellation in full if include_pix=True, else it just multiplies by the MAS window if data=True.

    Parameters
    ----------
    input_map : ndarray
        The input map.
    nbar : ndarray
        Map of the background number density.
    MAS_mat : ndarray
        The mass assignment (i.e. compensation) matrix.
    Y_lms : list
        List of spherical harmonic functions, generated by Ylm.
    k_grids : ndarray
        3D grids containing the (k_x,k_y,k_z) values.
    r_grids : ndarray
        3D grids containing the (r_x,r_y,r_z) values.
    v_cell : float
        Cell volume.
    k_filters : ndarray
        3D boolean maps describing the k bins.
    k_norm : float
        3D map of |k|.
    i : int
        Multipole index.
    a : int
        k bin index.
    include_pix : bool, optional
        Whether to include the MAS effects in the covariance (default: True).
    data : bool, optional
        Whether to include the pixelation in data covariance (default: False).

    Returns
    -------
    ndarray
        The derivatives C_{,alpha}(r,r') applied to the input map x(r') for a single multipole and bin.
    """
    if include_pix:
        tmp_map = ift(ft(input_map)/MAS_mat)*nbar
    else:
        tmp_map = input_map*nbar

    # Compute Sum_m Y_lm(k)FT[Y_lm(r)n(r)x(r)]
    f_nx_l = 0.

    for m_i in range(len(Y_lms[i])):
        f_nx_l += ft(tmp_map*Y_lms[i][m_i](*r_grids))*Y_lms[i][m_i](*k_grids)

    if not include_pix:
        if data:
            # add in factor of M^2 to remove pixellation effects (for data only)
            f_nx_l *= MAS_mat**2.

    tmp2 = 4.*np.pi/(4.*i+1.)*k_filters(a,k_norm)*f_nx_l

    # Add to output array
    if include_pix:
        return ift(ft(nbar*ift(tmp2))/MAS_mat)/v_cell
    else:
        return nbar*ift(tmp2)/v_cell
